%!TeX program = xelatex
\documentclass{/Users/hi/Study/template/code}
%--------------------------------- Head -------------------------------------
\title{CABAC}
\author{\textcopyright Yang-datong }
\date{2024-08-20 14:38}

\begin{document}
\makehead
%我想让你扮演一名音视频编解码算法老师。我将提供一些音视频概念，你的工作是用易于理解的术语来解释它们。这可能包括提供解决问题的分步说明、用视觉演示各种技术或建议在线资源以供进一步研究。我的第一个请求是“文本算术编码中，如何对文本进行二进制化? 截断莱斯二元化是什么？K阶指数哥伦布二元化是什么？定长二元化是什么？”

%CABAC 仅在标准的主要和更高配置文件（而不是扩展配置文件）中受支持，因为与称为上下文自适应的更简单方案相比，它需要大量的处理来解码标准的基线配置文件中使用的可变长度编码(CAVLC)。 CABAC 也很难并行化和矢量化，因此可以结合使用其他形式的并行性（例如空间区域并行性）。在 HEVC 中，CABAC 用于该标准的所有配置文件中。

%--------------------------------- Body -------------------------------------
\section{算术编码}
\subsection{文本算术编码}
早期的压缩方法（如霍夫曼编码）在处理符号时存在一定的局限性，尤其是在符号频率分布不均的情况下。为了提高数据压缩的效率于是有了算术编码。

算术编码是一种无损数据压缩技术，它通过将整个消息视为一个单一的数字区间来实现压缩。与传统的霍夫曼编码不同，算术编码不使用离散的符号，而是将整个消息编码为一个在0到1之间的浮点数。

算术编码的基本步骤如下：
\begin{serialNumber}
	\item 概率模型：为每个符号分配一个概率，通常基于历史数据。
	\item 区间划分：根据符号的概率，将区间[0, 1)划分为多个子区间。
	\item 逐步缩小区间：对于每个符号，根据其概率区间逐步缩小当前区间，直到处理完所有符号。
	\item 输出编码：最终输出的编码是当前区间的一个浮点数，通常选择区间的中点。
\end{serialNumber}

算术编码分为浮点算术编码与定点算术编码，对浮点算术编码而言,用$[0, 1]$的概率区间，对一串字符编码后，得到了最终区间，在最终区间挑选一个数字作为编码输出，而这个数字是一个小数，受计算机精度的影响。
\begin{remark}
	为了避免浮点数的计算效率低的情况，在实际使用中采用定点算术编码，且根据计算机的精度采用比例缩放的方法来解决。在H264/H265中将[0, 1]区间放到至[0,210]，采用32位的寄存器实现。
\end{remark}

\begin{tcolorbox}
	\small
	假设要编码字符串 "ABAC"。我们首先需要定义每个符号的概率。假设我们有以下概率分布：
	%\newcolumntype{L}{>{\arraybackslash}p{5cm}}
	\begin{longtable}{ccc}
		%------------ Name ---------------
		%------------ Head ----------------
		\toprule
		\textbf{A} & \textbf{B} & \textbf{C} \\
		\midrule
		\endfirsthead
		%---------- Breakable --------------
		\bottomrule()
		\multicolumn{3}{r}{续下页}
		\endfoot
		%------------ Bottom ---------------
		\bottomrule()
		\endlastfoot
		%------------- Main ----------------
		0.5        & 0.25       & 0.25
	\end{longtable}

	\begin{serialNumber}
		\item 定义区间：根据每个符号的概率，定义每个符号对应的区间：
		%\newcolumntype{L}{>{\arraybackslash}p{5cm}}
		\begin{longtable}{ccc}
			%------------ Name ---------------
			%------------ Head ----------------
			\toprule
			\textbf{A} & \textbf{B}  & \textbf{C}  \\
			\midrule
			\endfirsthead
			%---------- Breakable --------------
			\bottomrule()
			\multicolumn{3}{r}{续下页}
			\endfoot
			%------------ Bottom ---------------
			\bottomrule()
			\endlastfoot
			%------------- Main ----------------
			[0.0, 0.5) & [0.5, 0.75) & [0.75, 1.0) \\
		\end{longtable}

		\item 初始化区间：初始化一个区间 [low, high) 为 [0.0, 1.0)。
		\item 逐个符号编码：逐个处理字符串中的符号，并更新当前区间。
		\begin{equation}
			[low,high) \rightarrow  [low + (high - low)Symbol_{low} , low + ( high - low )Symbol_{high}]
		\end{equation}
		\begin{itemize}
			\item  处理第一个符号 'A': 当前区间: [0.0, 1.0)，新区间计算:low = 0.0，high = 0.0 + (1.0 - 0.0)  0.5 = 0.5，更新后的区间: [0.0, 0.5)
			\item  处理第二个符号 'B': 当前区间: [0.0, 0.5) ,新区间计算: low = 0.0 + (0.5 - 0.0)  0.5 = 0.25 ,high = 0.0 + (0.5 - 0.0)  0.75 = 0.375 ,更新后的区间: [0.25, 0.375)
			\item  处理第三个符号 'A': 当前区间: [0.25, 0.375) ,新区间计算: low = 0.25 + (0.375 - 0.25)  0.5 = 0.3125 ,high = 0.25 + (0.375 - 0.25)  0.5 = 0.34375 ,更新后的区间: [0.3125, 0.34375)
			\item  处理第四个符号 'C': 当前区间: [0.3125, 0.34375) ,新区间计算: low = 0.3125 + (0.34375 - 0.3125)  0.75 = 0.340625 ,high = 0.3125 + (0.34375 - 0.3125)  1.0 = 0.34375 ,更新后的区间: [0.340625, 0.34375)
		\end{itemize}

		\item 输出编码值：选择区间内的任意一个值作为编码结果，通常选择区间的中点。这里可以选择：
		\begin{equation}
			\text{编码值} = \frac{0.340625 + 0.34375}{2} = 0.3421875
		\end{equation}
	\end{serialNumber}
\end{tcolorbox}


\subsection{二进制算术编码}
文本算术编码处理的是字符数据，通常是ASCII或Unicode字符，需要处理字符集和更复杂的概率模型。而二进制算术编码处理的是二进制数据（0和1），通常只有两个符号（0和1），概率分布简单。

\subsubsection{二进制化}
\paragraph{定长二元化}
定长二元化（Fixed-Length Coding）是一种简单的编码方法，其中每个符号都被分配一个固定长度的二进制代码。其特点包括：

固定长度：每个字符或符号的二进制表示长度相同，例如，使用8位表示所有字符。

简单性：由于每个符号的长度相同，解码过程非常简单。

效率：在某些情况下，定长编码可能会导致空间浪费，尤其是当字符集较小而编码长度较大时。

例如，在ASCII中，字符'A'的二进制表示是01000001。


\paragraph{截断莱斯二元化}
截断莱斯二元化（Truncated Rice Coding）是一种用于无损数据压缩的编码方法。它的基本思想是：
\begin{serialNumber}
	\item 分段编码：选择一个参数$k ( k > 0 , k \in N )$，由$k$决定编码的分段大小，从而将数据分成多个段，每个段的长度是可变的。
	\item 商和余数：将要编码的数$ N $表示为商和余数的形式：\( N = q \cdot 2^k + r \)，其中\( q \)是商，\( r \)是余数。
	\item 编码商：用一串\( q \)个1后跟一个0来表示商。如，$q = 3$则编码为"1110"
	\item 编码余数：用\( k \)位二进制数来表示余数。如， 余数为2，但$k = 3$，则编码为"010"
	\item 截断：在编码过程中，如果某个段的长度超过预设的最大值，则将其截断，以避免过长的编码。
\end{serialNumber}
C++实现代码见文末。



\paragraph{K阶指数哥伦布二元化}
K阶指数哥伦布二元化（K-th Order Exponential Golomb Coding）是一种改进的哥伦布编码方法，也是一种变长编码方法，适用于无符号整数、具有特定概率分布的数据。其步骤包括：
%  TODO YangJing  <24-08-24 00:23:46> % 
%https://blog.51cto.com/u_15296426/3029428
%https://www.cnblogs.com/SoaringLee/p/10532499.html
%\begin{serialNumber}
%	\item 概率模型：根据数据的概率分布，选择合适的$k$值。
%	\item 编码过程：使用K阶指数函数来生成编码，通常用于表示较大的整数，比如要编码的数$N$表示为$( N + 2^{k} )$。
%	\item 输出二进制：将生成的编码转换为二进制形式。
%	\item 前缀和后缀：将二进制数分为前缀和后缀，前缀部分由一串0和一个1组成，后缀部分是剩余的二进制数。
%	\item 组合：将前缀和后缀组合起来，得到最终的编码。
%\end{serialNumber}

\subsubsection{上下文建模}
\begin{definition}
	上下文建模是指在进行数据编码时，利用当前符号（或数据）的上下文信息来预测其概率分布，从而更有效地进行编码。
\end{definition}

上下文：可以是前面已经编码的符号或数据。例如，在编码一个文本时，当前字符的上下文可能是前面几个字符。

概率估计：算术编码通过上下文建模来估计当前符号出现的概率。如果某个符号在特定上下文中出现的频率较高，编码器就会为这个符号分配一个较小的概率值，这样可以用更少的比特位表示它。

动态更新：上下文模型可以是静态的（使用固定的概率表）或动态的（根据编码过程中遇到的数据实时更新概率）。动态模型通常能提供更好的压缩效果，因为它能够适应数据的变化。


\paragraph{MPS概率模型变量}
\begin{definition}
	MPS（Most Probable Symbol）概率模型是算术编码中用来表示当前符号最可能值的概率模型。MPS概率模型变量用于跟踪当前上下文中最可能出现的符号及其概率。在二进制编码中，MPS可能是0或1，表示在给定上下文下，哪个符号更有可能出现。
\end{definition}
\begin{remark}
	反之，LPS为最小概率符号
\end{remark}

在算术编码过程中，编码器会根据MPS概率模型决定如何划分当前区间，以便更有效地编码当前符号。

\paragraph{pStateIdx概率模型变量}
\begin{definition}
	pStateIdx（Probability State Index）是指在上下文建模中，用于表示当前上下文状态的索引。它帮助编码器选择合适的概率模型以进行符号编码。它是一个索引变量，用于指示当前上下文状态对应的概率模型。它通常是一个整数值，指向一个预定义的概率表。
\end{definition}

通过使用pStateIdx，编码器可以快速访问与当前上下文相关的概率分布，以便于进行符号的算术编码。

\subsubsection{算术编码}
由于输入只有两个符号：“0”，“1”，那么简单得根据实际情况'1'的个数多则MPS = 1, LPS = 0。反之，MPS = 0 , LPS = 1，根据符号的出现概率，将区间划分为不同的子区间。例如，MPS = 1 的概率为 0.8，LPS = 0 的概率为 0.2，那么可以将区间 [0, 1) 划分为 [0, 0.8) 和 [0.2, 1)。

\begin{tcolorbox}
	\small
	假设要编码的二进制序列是 110010，且已知 MPS = 1 (概率 0.8)，LPS = 0 (概率 0.2)。
	\begin{serialNumber}
		\item 定义区间：根据每个符号的概率，定义每个符号对应的区间：
		%\newcolumntype{L}{>{\arraybackslash}p{5cm}}
		\begin{longtable}{cc}
			%------------ Name ---------------
			%------------ Head ----------------
			\toprule
			\textbf{MPS} & \textbf{LPS} \\
			\midrule
			\endfirsthead
			%---------- Breakable --------------
			\bottomrule()
			\multicolumn{2}{r}{续下页}
			\endfoot
			%------------ Bottom ---------------
			\bottomrule()
			\endlastfoot
			%------------- Main ----------------
			[0.0, 0.8)   & [0.8, 1.0)   \\
		\end{longtable}

		\item 初始化区间：初始化一个区间 [low, high) 为 [0.0, 1.0)。
		\item 逐个符号编码：逐个处理二进制序列中的符号，并更新当前区间。
		\begin{equation}
			\begin{cases}
				range = high - low                                                                    \\
				[low,high) \rightarrow  [low ,  low' + range * P( MPS ) )                 & For ~ MPS \\
				[low,high) \rightarrow  [low + range * P( MPS ) ,low' + range * P( LPS )) & For ~ LPS
			\end{cases}
		\end{equation}
		其中，low'指的是当前区间的低区间计算后的新低区间。

		\begin{itemize}
			\item 编码第一个符号 1：区间 [0, 1) 划分为 [0, 0.8) 和 [0.8, 1)。选择 MPS 区间 [0, 0.8)。
			\item 编码第二个符号 1：新区间 [0, 0.8) 划分为 [0, 0.64) (MPS) 和 [0.64, 0.16) (LPS)。选择 MPS 区间 [0, 0.64)。
			\item 编码第三个符号 0：新区间 [0, 0.64) 划分为 [0, 0.64 * 0.8) (MPS) 和 [0.64 * 0.8, 0.64 * 0.8 + 0.64 * 0.2) (LPS)。选择 LPS 区间 [0.512, 0.64)。
			\item 编码第四个符号 0：新区间 [0.512, 0.64) 划分为 [0.512, (0.64 - 0.512) * 0.8) (MPS) 和 [0.512 + (0.64 - 0.512) * 0.8 ,0.6144 + (0.64 - 0.512) * 0.2 ) (LPS)。选择 LPS 区间 [0.6144, 0.64)。
			\item 编码第五个符号 1：新区间 [0.6144, 0.64) 划分为 [0.6144, 0.6144 + (0.64-0.6144)*0.8) (MPS) 和 [0.6144 + (0.64-0.6144)*0.8, 0.63488 + (0.64-0.6144)*0.2) (LPS)。选择 MPS 区间 [0.6144, 0.2048)，选择MPS区间为 [0.6144,0.63488)。
			\item 编码第六个符号 0：新区间 [0.6144, 0.63488) 划分为 [0.6144, 0.6144 + 0.02048 * 0.8) (MPS) 和 [0.6144 + 0.02048 * 0.8,0.630784 + 0.02048 * 0.2) (LPS)。选择 LPS 区间 [0.630784, 0.63488)。
		\end{itemize}

		\item 输出编码值：选择区间内的任意一个值作为编码结果，通常选择区间的中点。这里可以选择：
		\begin{equation}
			\text{编码值} = \frac{0.630784 + 0.63488}{2} = 0.632832
		\end{equation}
	\end{serialNumber}


\end{tcolorbox}

\begin{tcolorbox}
	\small
	对0.632832进行解码，已知条件为初始化区间[0,1)，以及P(MPS) = 0.8 , P(LPS) = 0.2
	\begin{serialNumber}
		\item 计算范围: range = high - low = 1 - 0 = 1，
		判断第一个符号: mid = low + range * P(MPS) = 0 + 1 * 0.8 = 0.8，由于 value < mid，所以符号为 1 (MPS)，
		更新区间：high = mid = 0.8

		\item 计算范围: range = high - low = 0.8 - 0 = 0.8，
		判断第二个符号: mid = low + range * P(MPS) = 0 + 0.8 * 0.8 = 0.64，由于 value < mid，所以符号为 1 (MPS)，
		更新区间：high = mid = 0.64
		\item 计算范围: range = high - low = 0.64 - 0 = 0.64，
		判断第三个符号: mid = low + range * P(MPS) = 0 + 0.64 * 0.8 = 0.512，由于 value >= mid，所以符号为 0 (LPS)，
		更新区间：low = mid = 0.512

		\item 计算范围: range = high - low = 0.64 - 0.512 = 0.128，
		判断第四个符号: mid = low + range * P(MPS) = 0.512 + 0.128 * 0.8 = 0.6144，由于 value >= mid，所以符号为 0 (LPS)，
		更新区间：low = mid = 0.6144

		\item 计算范围: range = high - low = 0.64 - 0.6144 = 0.0256，
		判断第五个符号: mid = low + range * P(MPS) = 0.6144 + 0.0256 * 0.8 = 0.63488，由于 value < mid，所以符号为 1 (MPS)，
		更新区间：high = mid = 0.63488

		\item 计算范围: range = high - low = 0.63488 - 0.6144 = 0.02048，
		判断第六个符号: mid = low + range * P(MPS) = 0.6144 + 0.02048 * 0.8 = 0.630784，由于 value >= mid，所以符号为 0 (LPS)，
		更新区间：low = mid = 0.630784
	\end{serialNumber}

	通过上述步骤可以解码出原始序列 110010。
\end{tcolorbox}


\newpage
\section{CABAC编码}
CABAC（Context-Adaptive Binary Arithmetic Coding）是一种用于视频压缩的熵编码算法，广泛应用于H.264/AVC和HEVC（H.265）视频编码标准中。CABAC通过利用上下文信息来自适应地编码二进制符号，从而实现高效的压缩。其主要特点：
\begin{itemize}
	\item 上下文自适应：CABAC根据符号的上下文信息（如前面符号的统计特性）来选择概率模型，从而提高编码效率。
	\item 二进制算术编码：CABAC使用算术编码对二进制符号进行编码，这种方法比传统的霍夫曼编码更接近熵极限，能更好地压缩数据。
	\item 高压缩率：由于其自适应性和高效的算术编码，CABAC通常能比其他熵编码方法（如CAVLC）提供更高的压缩率。
\end{itemize}

CABAC编码过程主要包括以下几个步骤：
\begin{itemize}
	\item 上下文变量的初始化：确定所有上下文的初始MPS以及初始状态pStateIdx。
	\item 二进制化：将非二进制符号（如运动矢量、残差系数等）转换为二进制符号。
	\item 上下文建模：根据符号的上下文信息选择合适的概率模型。上下文信息可以包括前面符号的值、位置等。
	\item 算术编码：使用选定的概率模型对二进制符号进行算术编码。
\end{itemize}

\subsection{上下文变量的初始化}
在 H.264中，CABAC 初始化上下文变量是通过使用预定义的表格来完成的。这个过程与视频的编码类型和片头信息有关。初始化步骤：

\begin{serialNumber}
	\item 选择初始化表：H.264 标准提供了多组初始化表，根据不同的编码类型（如 I 帧或 P/B 帧）选择不同的表。这些表包括不同的上下文模型初始状态，通常由两个参数表示：m 和 n。
	\item 计算初始概率: 使用如下公式计算每个上下文的初始概率：
	\begin{gather}
		\text{preCtxStateIdx} = Clip3(1, 126, (m \times \text{QP} / 4) + n) \\
		p_{\text{init}} = Clip3(1, 126, \frac{1}{2}((\text{preCtxStateIdx} \times 5) + 5))
	\end{gather}
	其中，QP 是量化参数，$Clip3$表示为第三个参数的值域应该为$[1,126]$，若不为处于该区间，则就近取值。

	\item 确定初始状态: 根据 $p_{\text{init}}$ 值来初始化每个上下文变量的状态（即 MPS/LPS 状态和概率估计）。
	\item 上下文建模: 每个上下文模型根据场景（如运动矢量、块类型）选择相应的上下文。
\end{serialNumber}

这种初始化方法保证了 CABAC 的自适应性，能有效地压缩数据，同时保持编码的灵活性和效率。


\newpage
\section{CABAC解码}
CABAC解码在H264一般是用于解码Slice Data的数据，具体来说流程图（见166 ITU-T Rec. H.264 (05/2003)）


\newpage
\section{熵编码}
\begin{definition}
	信息熵是一个衡量信息不确定性的概念，通常用在信息论中。它由克劳德·香农（Claude Shannon）在1948年提出，用于量化信息的内容或复杂性。
	信息熵通常用符号 \( H(X) \) 表示，其中 \( X \) 是随机变量，其可能的结果有 \( x_1, x_2, ..., x_n \)。信息熵的计算公式如下：
	\begin{equation}
		H( X ) = - \sum_{i=1}^{n} p( x_i  ) \log_2 p( x_i )
	\end{equation}
\end{definition}
其中，\( p(x_i) \) 是事件 \( x_i \) 发生的概率。这样计算出的熵单位是“比特”（bit）。

假设有一个均匀分布的骰子，六个面都有相同的概率出现，每个面的概率 \( p(x_i) = \dfrac{1}{6} \),则熵计算为：
\begin{equation}
	H(X) = -\left(6 \times \frac{1}{6} \log_2 \frac{1}{6}\right) = -\log_2 \frac{1}{6} = 3 ~ bits
\end{equation}

\newpage
\section{代码实现}
\subsection{截断莱斯二元化}
\begin{lstlisting}[language=c++]
#include <bitset>
#include <iostream>

using namespace std;

// 编码函数
string riceEncode(int N, int k) {
  /* 0001 0111 >> 3 = 0010 = 2 */
  int q = N >> k;             // 商
                              /* 0001 0111 & 1000 - 1 = 111 = 3 */
  int r = N & ((1 << k) - 1); // 余数

  // 编码商
  string encoded = string(q, '1') + "0";

  // 编码余数
  bitset<32> binaryR(r);
  string binaryRStr = binaryR.to_string().substr(32 - k, k);
  encoded += binaryRStr;

  return encoded;
}

// 解码函数
int riceDecode(const string &encoded, int k) {
  int q = 0;
  int readToZeor = 0;

  // 解码商
  while (encoded[readToZeor] == '1') {
    q++;
    readToZeor++;
  }
  readToZeor++; // 跳过 '0'

  // 解码余数
  int r = 0;
  for (int i = 0; i < k; i++) {
    /* 这里减去字符'0'是字符和整数之间的转换 */
    r = (r << 1) | (encoded[readToZeor] - '0');
    readToZeor++;
  }

  return (q << k) + r;
}

// 比如，对23进行编码，那么选定任意$k = 3$,则$23 = q * 2^3 + r$，得出q = 2 , r = 7，则q = "110" , r = "111"，则编码结果为"110111"
// 反之，对"110111"进行解码，那么先读到第一个'0'，即"110"，解码为 q = 2, 根据参数k=3可知，再继续读取3位则为余数r = b'111' = 7, 故$2 * 2^3 + 7 = 23$

const int k = 3; // 参数 k
int main() {
  int N = 23; // 要编码的数
  cout << "Encoded: " << riceEncode(N, k) << endl;
  cout << "Decoded: " << riceDecode("110111", k) << endl;
  return 0;
}
\end{lstlisting}

%--------------------------------- Reference --------------------------------
\newpage
\begin{thebibliography}{1}
	\bibitem{a} 作者. \emph{文献}[M]. 地点:出版社,年份.\url{www.google.com}
\end{thebibliography}

\end{document}
