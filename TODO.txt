1. CABAC(上下文自适应二进制算术编码)
2. B Slice的直接模式（B_Skip 和 B_Direct 模式）：
	B_Skip：没有显式编码运动矢量，解码器直接推导出运动矢量。
	B_Direct：类似于B_Skip，通过周围块的信息来推导运动矢量。

H264中，场图像（field_pic_flag）与场宏块（mb_field_decoding_flag）的区别:
场图像（field_pic_flag）
	定义：指示整个图像是场图像而不是帧图像。
	作用：图像被编码为两个场（顶场和底场），每个场只包含原始帧的一半扫描线。
	使用场景：通常用于处理隔行扫描的视频，减少运动伪影。
场宏块（mb_field_decoding_flag）
	定义：指示宏块是否采用场编码模式。
	作用：即使在帧图像中，也可以对宏块使用场编码，以更好地处理垂直运动。
	适应性：允许在帧编码和场编码之间灵活切换，提高编码效率和视频质量。

区别
	作用范围：
		field_pic_flag 影响整个图像的编码方式。
		mb_field_decoding_flag 只影响单个宏块的编码方式。
	灵活性：
		field_pic_flag 决定了图像层级的处理方式。
		mb_field_decoding_flag 提供了更细粒度的控制，允许在帧图像中混合使用场编码宏块。


运动矢量差 (MVD):
    在帧间预测中，运动矢量用于指示当前宏块部分在参考帧中的位置。解码器通过运动矢量从参考帧中找到对应的块，并将其作为当前块的预测值。
    运动矢量差是编码器为了压缩运动矢量信息而存储的差值。解码器通过解码运动矢量差，再加上预测运动矢量，得到实际的运动矢量。


宏块划分模式

在 H.264 中，宏块（16x16 像素）可以根据不同的模式划分为不同数量的子宏块：

    16x16 模式：
        整个宏块不划分，作为一个 16x16 的块处理。
        子宏块数量：1 个。

    16x8 模式：
        宏块被划分为两个 16x8 的子宏块。
        子宏块数量：2 个。

    8x16 模式：
        宏块被划分为两个 8x16 的子宏块。
        子宏块数量：2 个。

    8x8 模式：
        宏块被划分为四个 8x8 的子宏块。
        子宏块数量：4 个。

    在 8x8 模式下，每个 8x8 的子宏块还可以进一步划分为更小的块：
        8x8（不再划分）
        8x4（划分为两个 8x4 的块）
        4x8（划分为两个 4x8 的块）
        4x4（划分为四个 4x4 的块）

编码块模式（Coded Block Pattern, CBP）是一个重要的概念，它用于指示哪些块（亮度块和色度块）包含非零的变换系数。CBP的值决定了在解码过程中哪些块需要进行逆变换和反量化。

8x8变换与传统的4x4变换? 8x8变换是一种更大的块变换，相比传统的4x4变换，它可以更有效地压缩低频信息，特别是在平滑区域。使用8x8变换可以提高编码效率，减少块效应（block artifacts）



帧内残差编码（Intra）：帧内编码的宏块是通过当前帧的像素进行预测的，不依赖其他帧。H.264 中有多种帧内预测模式，比如 Intra4x4、Intra16x16 等。Intra16x16 是一种帧内预测模式，表示整个 16x16 宏块使用一个预测模式进行编码。对于这种模式，残差数据分为 DC 和 AC 两部分，分别表示宏块的平均亮度值和细节变化。

帧间残差（Inter）：帧间编码的宏块是通过参考帧进行预测的（即 P 帧和 B 帧）。帧间编码的宏块通过运动补偿来预测当前宏块的像素值，残差数据表示预测值与实际值之间的差异。


几个重要的分支：
1. CAVLC编码与CABAC编码
2. 帧编码与场编码
3. 是否MBFF模式
4. 是否使用transform_size_8x8 变换
5. 是否CbCr有降采样，如YUV444、YUV400 与YUV420、YUV422的处理




H264中量化操作的关键字： Scaling process(量化涉及缩放因子应用到变换系数上，反量化则是将缩放后的系数转换回近似的原始值。)


H264中使用了简单的DCT变换（整数变换，因为浮点数运算太慢了,如JPEG）



/* TODO YangJing 明白了，这里是因为越界了，覆盖了RefPicList0的数据，原来只有16个大小，而这里刚好覆盖了数组的下届内存，即RefPicList0Length <24-09-08 22:03:12> */
先处理dpb大小问题
