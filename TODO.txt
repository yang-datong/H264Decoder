1. CABAC(上下文自适应二进制算术编码)
2. B Slice的直接模式（B_Skip 和 B_Direct 模式）：
	B_Skip：没有显式编码运动矢量，解码器直接推导出运动矢量。
	B_Direct：类似于B_Skip，通过周围块的信息来推导运动矢量。

H264中，场图像（field_pic_flag）与场宏块（mb_field_decoding_flag）的区别:
场图像（field_pic_flag）
	定义：指示整个图像是场图像而不是帧图像。
	作用：图像被编码为两个场（顶场和底场），每个场只包含原始帧的一半扫描线。
	使用场景：通常用于处理隔行扫描的视频，减少运动伪影。
场宏块（mb_field_decoding_flag）
	定义：指示宏块是否采用场编码模式。
	作用：即使在帧图像中，也可以对宏块使用场编码，以更好地处理垂直运动。
	适应性：允许在帧编码和场编码之间灵活切换，提高编码效率和视频质量。

区别
	作用范围：
		field_pic_flag 影响整个图像的编码方式。
		mb_field_decoding_flag 只影响单个宏块的编码方式。
	灵活性：
		field_pic_flag 决定了图像层级的处理方式。
		mb_field_decoding_flag 提供了更细粒度的控制，允许在帧图像中混合使用场编码宏块。


运动矢量差 (MVD):
    在帧间预测中，运动矢量用于指示当前宏块部分在参考帧中的位置。解码器通过运动矢量从参考帧中找到对应的块，并将其作为当前块的预测值。
    运动矢量差是编码器为了压缩运动矢量信息而存储的差值。解码器通过解码运动矢量差，再加上预测运动矢量，得到实际的运动矢量。


宏块划分模式

在 H.264 中，宏块（16x16 像素）可以根据不同的模式划分为不同数量的子宏块：

    16x16 模式：
        整个宏块不划分，作为一个 16x16 的块处理。
        子宏块数量：1 个。

    16x8 模式：
        宏块被划分为两个 16x8 的子宏块。
        子宏块数量：2 个。

    8x16 模式：
        宏块被划分为两个 8x16 的子宏块。
        子宏块数量：2 个。

    8x8 模式：
        宏块被划分为四个 8x8 的子宏块。
        子宏块数量：4 个。

    在 8x8 模式下，每个 8x8 的子宏块还可以进一步划分为更小的块：
        8x8（不再划分）
        8x4（划分为两个 8x4 的块）
        4x8（划分为两个 4x8 的块）
        4x4（划分为四个 4x4 的块）

编码块模式（Coded Block Pattern, CBP）是一个重要的概念，它用于指示哪些块（亮度块和色度块）包含非零的变换系数。CBP的值决定了在解码过程中哪些块需要进行逆变换和反量化。

8x8变换与传统的4x4变换? 8x8变换是一种更大的块变换，相比传统的4x4变换，它可以更有效地压缩低频信息，特别是在平滑区域。使用8x8变换可以提高编码效率，减少块效应（block artifacts）



帧内残差编码（Intra）：帧内编码的宏块是通过当前帧的像素进行预测的，不依赖其他帧。H.264 中有多种帧内预测模式，比如 Intra4x4、Intra16x16 等。Intra16x16 是一种帧内预测模式，表示整个 16x16 宏块使用一个预测模式进行编码。对于这种模式，残差数据分为 DC 和 AC 两部分，分别表示宏块的平均亮度值和细节变化。

帧间残差（Inter）：帧间编码的宏块是通过参考帧进行预测的（即 P 帧和 B 帧）。帧间编码的宏块通过运动补偿来预测当前宏块的像素值，残差数据表示预测值与实际值之间的差异。


几个重要的分支：
1. CAVLC编码与CABAC编码
2. 帧编码与场编码
3. 是否MBFF模式
4. 是否使用transform_size_8x8 变换
5. 是否CbCr有降采样，如YUV444、YUV400 与YUV420、YUV422的处理




H264中量化操作的关键字： Scaling process(量化涉及缩放因子应用到变换系数上，反量化则是将缩放后的系数转换回近似的原始值。)


H264中使用了简单的DCT变换（整数变换，因为浮点数运算太慢了,如JPEG）



IDR与I Slice: 
1. I 帧（Intra Frame）：

    I 帧是帧内编码的帧，它只依赖于自身进行解码，不依赖其他帧。
    I 帧可以出现在 GOP 的任意位置。
    I 帧不一定是 IDR 帧，这意味着后续的 P 帧或 B 帧仍然可以参考 I 帧之前的帧（即跨 GOP 参考）。

2. IDR 帧（Instantaneous Decoder Refresh Frame）：

    IDR 帧是一种特殊的 I 帧，它不仅是帧内编码的，还会强制解码器丢弃之前的所有参考帧。
    当解码器遇到 IDR 帧时，后续的帧不会再参考 IDR 帧之前的任何帧，IDR 帧会刷新解码器的参考帧缓存。
    IDR 帧通常是 GOP 的起始帧。

I 帧不是 IDR 帧的情况：
    当编码器插入一个 I 帧，但不希望刷新解码器的参考帧缓存时，这个 I 帧就不是 IDR 帧。
    这种情况下，后续的 P 帧或 B 帧仍然可以参考 I 帧之前的帧（即跨 GOP 参考）。
    这种非 IDR 的 I 帧可以用于减少关键帧的插入频率，同时保持较高的压缩效率。

具体场景：
    场景切换检测：编码器可能会在场景切换时插入 I 帧，但不一定是 IDR 帧，因为场景切换可能不需要完全刷新参考帧。
    低延迟编码：在一些低延迟应用中，编码器可能会插入 I 帧而不是 IDR 帧，以减少解码器的延迟，同时允许跨 GOP 参考。

使用ffmpeg生成多I帧（非IDR帧）:
ffmpeg -i input.mp4 -c:v libx264 -g 100 -keyint_min 100 -x264-params "scenecut=0" -force_key_frames "expr:gte(t,n_forced*2)" output.h264
ffmpeg -i input.mp4 -c:v libx264 -x264opts keyint=50:scenecut=0 -force_key_frames "expr:gte(t,n_forced*2)" output.mp4


-g 100：设置 GOP 的大小为 100 帧（即每 100 帧插入一个 IDR 帧）。
-keyint_min 100：确保最小关键帧间隔为 100 帧。
-x264-params "scenecut=0"：禁用场景切换检测，防止自动插入 IDR 帧。
-force_key_frames "expr:gte(t,n_forced*2)"：每 2 秒强制插入一个 I 帧（非 IDR 帧）。


该命令会在每 2 秒插入一个 I 帧，但这些 I 帧不会是 IDR 帧，因此后续的 P 帧或 B 帧仍然可以参考这些 I 帧之前的帧。每 100 帧会有一个 IDR 帧，以确保 GOP 的结构。


帧、场：逐行扫描与隔行扫描


有个地方我记得写了很多else if ，其实就是else ，后面找一下在哪里 TODO  <24-10-18 08:50:45, YangJing> (相邻地址推导处）
